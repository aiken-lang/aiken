use std::path::PathBuf;

use aiken_lang::ast::{TraceLevel, Tracing};
use aiken_project::{options::Options, watch::with_project};

use super::build::{filter_traces_parser, trace_level_parser};

#[derive(clap::Args)]
pub struct Args {
    /// Path to project
    directory: Option<PathBuf>,

    /// Name of the function's module within the project
    #[clap(short, long)]
    module: String,

    /// Name of the function within the module
    #[clap(short, long)]
    name: String,

    /// Filter traces to be considered during testing:
    ///   - user-defined: only consider traces that you've explicitly defined (either through the
    ///   'trace' keyword of via the trace-if-false ('?') operator.
    ///   - compiler-generated: only included internal traces generated by the Aiken compiler, for
    ///   example in usage of 'expect'.
    ///   - all: include both user-defined and compiler-generated traces.
    /// [optional] [default: all]
    #[clap(short, long, value_parser=filter_traces_parser(), default_missing_value="all", verbatim_doc_comment)]
    filter_traces: Option<fn(TraceLevel) -> Tracing>,

    /// Choose the verbosity level of traces:
    ///   - silent: disable traces altogether
    ///   - compact: only culprit line numbers are shown on failures
    ///   - verbose: enable full verbose traces as provided by the user or the compiler
    /// [optional]
    #[clap(short, long, value_parser=trace_level_parser(), default_value_t=TraceLevel::Verbose, verbatim_doc_comment)]
    trace_level: TraceLevel,
}

pub fn exec(
    Args {
        directory,
        module,
        name,
        filter_traces,
        trace_level,
    }: Args,
) -> miette::Result<()> {
    with_project(directory.as_deref(), false, |p| {
        p.compile(Options::default())?;

        let export = p.export(
            &module,
            &name,
            match filter_traces {
                Some(filter_traces) => filter_traces(trace_level),
                None => Tracing::All(trace_level),
            },
        )?;

        let json = serde_json::to_string_pretty(&export).unwrap();

        println!("{}", json);

        Ok(())
    })
    .map_err(|_| std::process::exit(1))
}
