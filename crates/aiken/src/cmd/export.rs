#![allow(clippy::doc_overindented_list_items)]

use super::build::{trace_filter_parser, trace_level_parser};
use aiken_lang::ast::{TraceLevel, Tracing};
use aiken_project::{
    options::{Options, SourceMapMode},
    watch::with_project,
};
use std::path::PathBuf;

#[derive(clap::Args)]
#[clap(disable_version_flag(true))]
/// Export a function or test as a standalone UPLC program. Arguments to the function can be applied using
/// `aiken apply`.
pub struct Args {
    /// Path to project
    directory: Option<PathBuf>,

    /// List all exportable items (functions and tests)
    #[clap(short, long)]
    list: bool,

    /// Name of the function's module within the project
    #[clap(short, long, required_unless_present = "list")]
    module: Option<String>,

    /// Name of the function or test within the module
    #[clap(short, long, required_unless_present = "list")]
    name: Option<String>,

    /// Filter traces to be included in the generated program(s).
    ///
    ///   - user-defined:
    ///       only consider traces that you've explicitly defined
    ///       either through the 'trace' keyword of via the trace-if-false
    ///       ('?') operator.
    ///
    ///   - compiler-generated:
    ///       only included internal traces generated by the
    ///       Aiken compiler, for example in usage of 'expect'.
    ///
    ///   - all:
    ///       include both user-defined and compiler-generated traces.
    ///
    /// [optional] [default: all]
    #[clap(short = 'f', long, value_parser=trace_filter_parser(), default_missing_value="all", verbatim_doc_comment, alias = "filter_traces")]
    trace_filter: Option<fn(TraceLevel) -> Tracing>,

    /// Choose the verbosity level of traces:
    ///
    ///   - silent:
    ///       disable traces altogether
    ///
    ///   - compact:
    ///       only culprit line numbers are shown on failures
    ///
    ///   - verbose:
    ///       enable full verbose traces as provided by the user or the compiler
    ///
    /// [optional]
    #[clap(short, long, value_parser=trace_level_parser(), default_value_t=TraceLevel::Verbose, verbatim_doc_comment)]
    trace_level: TraceLevel,

    /// Include source map in the exported JSON for debugging support.
    ///
    /// [optional] [default: enabled]
    #[clap(long = "source-map", default_value_t = true, action = clap::ArgAction::Set)]
    source_map: bool,

    /// Skip performance optimizations (inlining, lambda reduction, etc).
    /// Produces larger code that maps more directly to source for debugging.
    ///
    /// [optional] [default: false]
    #[clap(long = "no-optimize", default_value_t = false)]
    no_optimize: bool,
}

pub fn exec(
    Args {
        directory,
        list,
        module,
        name,
        trace_filter,
        trace_level,
        source_map,
        no_optimize,
    }: Args,
) -> miette::Result<()> {
    with_project(directory.as_deref(), false, false, true, |p| {
        let tracing = match trace_filter {
            Some(trace_filter) => trace_filter(trace_level),
            None => Tracing::All(trace_level),
        };

        p.compile(Options {
            tracing,
            ..Options::default()
        })?;

        if list {
            let items = p.exportable_items();
            for (module_name, item_name, kind) in items {
                println!("{module_name}.{item_name} ({kind})");
            }
            return Ok(());
        }

        let module = module
            .as_ref()
            .expect("module is required when not using --list");
        let name = name
            .as_ref()
            .expect("name is required when not using --list");

        let source_map_mode = if source_map {
            SourceMapMode::Inline
        } else {
            SourceMapMode::None
        };

        let export = p.export(&module, &name, tracing, source_map_mode, no_optimize)?;

        let json = serde_json::to_string_pretty(&export).unwrap();

        println!("{json}");

        Ok(())
    })
    .map_err(|_| std::process::exit(1))
}
